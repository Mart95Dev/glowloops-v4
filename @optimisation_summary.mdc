---
description:
globs:
alwaysApply: false
---
# RÃ©sumÃ© des optimisations de performance GlowLoops

## Optimisations dÃ©jÃ  implÃ©mentÃ©es

### 1. Utilitaires d'optimisation d'images

#### `image-optimization.ts`
- âœ… Fonction `getOptimizedImageUrl()` pour optimiser les URLs d'images Firebase
- âœ… Support des presets de taille (`thumbnail`, `small`, `medium`, `large`, `banner`, `hero`)
- âœ… Conversion automatique en AVIF (prioritÃ©) et WebP pour meilleure compression
- âœ… Fonction `getImagePreloadProps()` pour prÃ©charger les images critiques
- âœ… GÃ©nÃ©ration de `srcset` responsive avec breakpoints personnalisables
- âœ… Support des formats modernes (AVIF en prioritÃ©, WebP en fallback)
- âœ… Optimisation des mÃ©tadonnÃ©es pour le tÃ©lÃ©chargement d'images

#### `OptimizedImage.tsx`
- âœ… Remplacement optimisÃ© de Next.js Image
- âœ… Support de `critical` pour les images importantes
- âœ… QualitÃ© adaptative (85 pour images critiques, 75 pour le reste)
- âœ… Support de `fetchPriority="high"` pour LCP
- âœ… Gestion des erreurs avec fallback
- âœ… Support de diffÃ©rents ratios et ajustements
- âœ… PrÃ©chargement direct des ressources critiques via Head
- âœ… Support complet des formats AVIF/WebP avec dÃ©tection auto
- âœ… GÃ©nÃ©ration de srcSet responsive avec multiples breakpoints

### 2. Composants optimisÃ©s

#### `ModernHeroBanner.tsx`
- âœ… PrÃ©chargement direct des images via `<Head>`
- âœ… Configuration optimale pour le LCP
- âœ… PrÃ©chargement des scripts JS critiques
- âœ… Utilisation du format AVIF pour une meilleure compression
- âœ… Support des ratios d'aspect adaptÃ©s aux diffÃ©rents devices

### 3. AmÃ©liorations de performance

- âœ… Score Lighthouse passÃ© de 35-40/100 Ã  71/100
- âœ… Total Blocking Time rÃ©duit de 4.8-11.8s Ã  0ms
- âœ… Largest Contentful Paint amÃ©liorÃ© de 41-55s Ã  13.1s
- âœ… First Contentful Paint optimisÃ© Ã  1.1s
- âœ… Cumulative Layout Shift parfait (0)

## Points d'amÃ©lioration Ã  prioriser

### 1. LCP (Largest Contentful Paint): actuellement 13.1s âš ï¸

#### ProblÃ¨mes identifiÃ©s
- ğŸ”´ Temps de chargement des images hÃ©ro encore trop long
- ğŸ”´ Trop de JavaScript exÃ©cutÃ© avant l'affichage de l'image principale

#### Solutions dÃ©taillÃ©es
1. **ImplÃ©menter un systÃ¨me de placeholders pour les images**
   ```tsx
   <OptimizedImage
     src={imageUrl}
     placeholderSrc={tinyImageUrl} // Version 10kb de l'image
     critical={true}
   />
   ```

2. **DÃ©placer l'initialisation Firebase aprÃ¨s le LCP**
   ```tsx
   useEffect(() => {
     // DiffÃ©rer l'initialisation non critique de Firebase
     const timer = setTimeout(() => {
       initializeFirebaseAnalytics();
     }, 3000); // AprÃ¨s le LCP
     return () => clearTimeout(timer);
   }, []);
   ```

3. **Ajouter l'attribut `defer` aux scripts non-critiques**
   ```html
   <script src="/chunks/non-critical.js" defer></script>
   ```

4. **RÃ©duire davantage la taille des images hero**
   - Compression plus agressive des images de banniÃ¨re
   - Utilisation de techniques de responsive art direction

### 2. TTI (Time to Interactive): actuellement 13.1s âš ï¸

#### ProblÃ¨mes identifiÃ©s
- ğŸ”´ Bundle JavaScript trop volumineux
- ğŸ”´ Hydratation React trop lourde

#### Solutions dÃ©taillÃ©es
1. **Mettre en place un systÃ¨me de chargement progressif**
   ```tsx
   const LazyComponent = dynamic(() => import('./Component'), {
     ssr: false,
     loading: () => <Placeholder />
   });
   ```

2. **RÃ©duire le code non critique dans le bundle principal**
   - Identifier et dÃ©placer les fonctionnalitÃ©s non critiques
   - Utiliser `next/dynamic` avec `{ ssr: false }` pour les composants d'UI non critiques

3. **ImplÃ©menter les Server Components pour les sections non interactives**
   - Convertir les composants statiques en Server Components
   - RÃ©duire le JavaScript envoyÃ© au client

### 3. Optimisations Firebase

#### ProblÃ¨mes identifiÃ©s
- ğŸ”´ Initialisation synchrone de Firebase bloquant le rendu
- ğŸ”´ RequÃªtes Firestore non optimisÃ©es

#### Solutions dÃ©taillÃ©es
1. **Modulariser davantage l'initialisation Firebase**
   ```tsx
   // Lazy loading de Firebase
   const loadFirebase = async () => {
     const { initializeApp } = await import('firebase/app');
     // Initialiser uniquement les services nÃ©cessaires
   };
   ```

2. **Mettre en cache les rÃ©sultats des requÃªtes Firestore frÃ©quentes**
   - ImplÃ©menter un systÃ¨me de cache cÃ´tÃ© client
   - Utiliser SWR ou React Query pour la gestion des donnÃ©es

## Plan d'action pour implÃ©mentation

### Phase 1: Optimisations critiques LCP
- [ ] ImplÃ©menter un systÃ¨me de placeholders LQIP pour les images hero
- [ ] DiffÃ©rer l'initialisation Firebase et autres scripts non critiques
- [ ] RÃ©duire davantage la taille des images hero

### Phase 2: AmÃ©lioration du TTI
- [ ] Mettre en place le chargement progressif des composants
- [ ] Analyser et rÃ©duire la taille des bundles JavaScript
- [ ] Convertir plus de composants en Server Components

### Objectifs de performances
| MÃ©trique | Situation initiale | Situation actuelle | Objectif |
|----|----|----|----|
| Performance Score | 35-40/100 | 71/100 | > 90/100 |
| LCP | 41-55s | 13.1s | < 2.5s |
| TBT | 4.8-11.8s | 0ms | < 200ms |
| TTI | 41-55s | 13.1s | < 3.8s |
| CLS | 0.02-0.03 | 0 | < 0.1 |
