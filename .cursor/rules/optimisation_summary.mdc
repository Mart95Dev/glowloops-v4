---
description:
globs:
alwaysApply: false
---
# R√©sum√© des optimisations de performance GlowLoops

## Optimisations d√©j√† impl√©ment√©es

### 1. Utilitaires d'optimisation d'images

#### `image-optimization.ts`
- ‚úÖ Fonction `getOptimizedImageUrl()` pour optimiser les URLs d'images Firebase
- ‚úÖ Support des presets de taille (`thumbnail`, `small`, `medium`, `large`, `banner`, `hero`)
- ‚úÖ Conversion automatique en WebP/AVIF pour meilleure compression
- ‚úÖ Fonction `getImagePreloadProps()` pour pr√©charger les images critiques
- ‚úÖ G√©n√©ration de `srcset` responsive

#### `firebase-image-optimizer.ts`
- ‚úÖ Cache c√¥t√© client pour √©viter de recalculer les URLs
- ‚úÖ Options d'optimisation sp√©cifiques par type d'image
- ‚úÖ Fonction `optimizeFirebaseImage()` avec support du cache
- ‚úÖ Conversion d'URLs Firebase Storage vers optimized CDN URLs
- ‚úÖ Support des attributs de pr√©chargement pour le LCP

### 2. Composant OptimizedImage

- ‚úÖ Remplacement optimis√© de Next.js Image
- ‚úÖ Support de `critical` pour les images importantes
- ‚úÖ Qualit√© adaptative (85 pour images critiques, 75 pour le reste)
- ‚úÖ Support de `fetchPriority="high"` pour LCP
- ‚úÖ Gestion des erreurs avec fallback
- ‚úÖ Support de diff√©rents ratios et ajustements

### 3. Configuration Next.js

#### Images
- ‚úÖ Support des formats modernes (AVIF/WebP)
- ‚úÖ Cache TTL augment√© (30 jours)
- ‚úÖ Tailles d'appareils optimis√©es

#### Webpack
- ‚úÖ D√©coupage sp√©cifique pour Firebase (core, auth, firestore, storage)
- ‚úÖ TerserPlugin avec multi-passes pour r√©duire la taille
- ‚úÖ Regroupement intelligent des modules

#### CSS
- ‚úÖ Optimisation avanc√©e avec cssnano
- ‚úÖ Inlining des petits CSS

#### Caching
- ‚úÖ Headers Cache-Control optimis√©s par type de ressource
- ‚úÖ Cache agressif pour ressources statiques et images

## Points d'am√©lioration √† prioriser

### 1. LCP (Largest Contentful Paint): actuellement 18.2s ‚ö†Ô∏è

#### Probl√®mes identifi√©s
- üî¥ Temps de chargement des images h√©ro trop long
- üî¥ Trop de JavaScript bloquant avant l'affichage de l'image principale
- üî¥ Pr√©chargement des assets critiques insuffisant

#### Solutions d√©taill√©es
1. **Impl√©menter un syst√®me de placeholders pour les images**
   ```tsx
   // Ajouter un placeholder low-quality √† OptimizedImage
   <OptimizedImage
     src={imageUrl}
     placeholderSrc={tinyImageUrl} // Version 10kb de l'image
     critical={true}
   />
   ```

2. **D√©placer l'initialisation Firebase apr√®s le LCP**
   ```tsx
   // Dans _app.tsx ou layout.tsx
   useEffect(() => {
     // Diff√©rer l'initialisation non critique de Firebase
     const timer = setTimeout(() => {
       initializeFirebaseAnalytics();
     }, 3000); // Apr√®s le LCP
     return () => clearTimeout(timer);
   }, []);
   ```

3. **Impl√©menter un syst√®me de streaming SSR pour le contenu critique**
   ```tsx
   // Dans la page d'accueil
   export default function HomePage() {
     return (
       <>
         <HeroBannerStreamed /> {/* Priorit√© absolue */}
         <Suspense fallback={<CategorySkeleton />}>
           <CategoryShowcase />
         </Suspense>
         {/* Autres composants moins critiques */}
       </>
     );
   }
   ```

### 2. TBT (Total Blocking Time): actuellement 1100ms ‚ö†Ô∏è

#### Probl√®mes identifi√©s
- üî¥ Trop de JavaScript ex√©cut√© sur le thread principal
- üî¥ Initialisation Firebase synchrone bloquante
- üî¥ Composants React avec trop de calculs au montage

#### Solutions d√©taill√©es
1. **Modulariser davantage l'initialisation Firebase**
   ```tsx
   // Cr√©er un hook personnalis√© pour charger Firebase √† la demande
   function useLazyFirebaseService(service) {
     const [instance, setInstance] = useState(null);
     
     const loadService = useCallback(async () => {
       const { initializeService } = await import('./firebase-services');
       const serviceInstance = await initializeService(service);
       setInstance(serviceInstance);
     }, [service]);
     
     return [instance, loadService];
   }
   ```

2. **D√©placer les calculs intensifs vers des Web Workers**
   - Cr√©er un fichier `performance-worker.js` pour les calculs lourds
   - D√©placer le traitement des donn√©es produits vers le worker

3. **Partitionner le rendu des composants lourds**
   ```tsx
   // Avant
   function ProductGrid({ products }) {
     return products.map(p => <ProductCard key={p.id} product={p} />);
   }
   
   // Apr√®s - avec partitionnement
   function ProductGrid({ products }) {
     return (
       <>
         <ProductBatch products={products.slice(0, 4)} priority />
         <Suspense>
           <ProductBatch products={products.slice(4)} />
         </Suspense>
       </>
     );
   }
   ```

### 3. TTI (Time to Interactive): actuellement 18.2s ‚ö†Ô∏è

#### Probl√®mes identifi√©s
- üî¥ Trop de scripts charg√©s au d√©marrage
- üî¥ Hydratation React trop lourde
- üî¥ Bundle principal trop volumineux

#### Solutions d√©taill√©es
1. **Mettre en place un syst√®me de chargement progressif**
   ```tsx
   // Dans le composant Layout
   const LazySearchBar = dynamic(() => import('./SearchBar'), {
     ssr: false,
     loading: () => <SearchBarPlaceholder />
   });
   ```

2. **R√©duire le code non critique dans le bundle principal**
   - Identifier et d√©placer les fonctionnalit√©s non critiques
   - Utiliser `next/dynamic` avec `{ ssr: false }` pour les composants d'UI non critiques
   - Utiliser l'option `optimizePackageImports` dans next.config.js pour plus de modules

3. **Impl√©menter une strat√©gie de "Progressive Hydration"**
   - Cr√©er un composant `<ProgressiveHydration>` personnalis√©
   - Hydrater uniquement les composants visibles dans la fen√™tre

### 4. Optimisations d'images sp√©cifiques

#### Probl√®mes identifi√©s
- üî¥ Format AVIF pas encore impl√©ment√© partout
- üî¥ Pr√©chargement parfois redondant
- üî¥ Qualit√© des images non optimale pour tous les contextes

#### Solutions d√©taill√©es
1. **Cr√©er une fonction d'analyse d'importance des images**
   ```tsx
   function analyzeImageImportance(imageUrl, context) {
     // D√©terminer si l'image est critique pour le LCP
     const isHero = context === 'hero';
     const isAboveFold = context === 'product-main' || context === 'banner';
     return {
       critical: isHero || isAboveFold,
       quality: isHero ? 85 : isAboveFold ? 80 : 75,
       priority: isHero ? 'high' : 'auto',
       format: isHero ? 'avif' : 'webp'
     };
   }
   ```

2. **Mettre en place un syst√®me de redimensionnement adaptatif au device**
   - Impl√©menter une d√©tection des capacit√©s du navigateur et de la connexion
   - Adapter la qualit√© selon la connexion (3G, 4G, WiFi)
   - Ajuster la taille des images selon la densit√© d'√©cran (1x, 2x, 3x)

## Plan d'action pour impl√©mentation

### Phase 1: Optimisations critiques LCP
- [ ] Impl√©menter le syst√®me de placeholders pour les images
- [ ] Diff√©rer l'initialisation Firebase
- [ ] Optimiser le HTML initial pour afficher le contenu visible rapidement

### Phase 2: R√©duction du TBT
- [ ] Modulariser davantage l'initialisation Firebase
- [ ] Impl√©menter des Web Workers pour les calculs lourds
- [ ] Optimiser les composants avec des calculs co√ªteux

### Phase 3: Am√©lioration du TTI
- [ ] Mettre en place le chargement progressif des composants
- [ ] R√©duire le code non critique
- [ ] Impl√©menter la "Progressive Hydration"

### Objectifs de performances
| M√©trique | Situation actuelle | Objectif |
|----------|-------------------|----------|
| LCP      | 18.2s             | < 2.5s   |
| TBT      | 1100ms            | < 200ms  |
| TTI      | 18.2s             | < 3.8s   |
| CLS      | 0.032             | < 0.1    |
| Score    | 47/100            | > 85/100 |
